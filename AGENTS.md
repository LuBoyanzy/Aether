# Repository Guidelines

1️⃣ 拒绝套娃式嵌套 - 用条件反转简化逻辑
2️⃣ 代码要"平铺直叙" - 减少嵌套更易读
3️⃣ 起名要见名知意 - 让同事秒懂你的代码

**在使用/review命令后，使用中文报告我**

# 最优先原则

**写代码时需要较为详细的注释！！！**
**使用中文输出，每写完一个小点或者一个小模块就说一下你干吗什么，这段代码是干什么用的**
**全程使用中文交流，你的思考和对话都是！！！**

## 重要规则

**不要自动启动前后端服务** - 用户会自己启动前后端服务，请勿主动运行以下命令：

- `./start.sh`
- `bash start.sh`
- `python main.py`
- `python manage.py runserver`
- `npm run dev`
- 或任何其他启动服务的命令

如果需要测试或验证功能，请告知用户需要重启服务，但不要自己执行。

# 代码生成规则 - 强制遵守

## 关键安全和质量规则

### 1. 绝不擅自做主

- **只能**修改明确要求的内容
- **绝不**改动无关的代码、文件或功能
- 如果觉得其他地方需要改动，**先问**
- 改动任何未明确要求的内容都是**禁止行为**

### 2. 依赖管理是必须的

- 添加import时**必须**更新package.json/requirements.txt
- **绝不**添加import语句而不声明对应依赖
- 建议代码前**先确认**所有依赖都已正确声明

### 3. 占位符是大忌

- **绝不**使用"YOUR_API_KEY"、"TODO"或虚拟数据
- **总是**使用合适的变量引用或配置模式
- 需要真实值时，**明确询问**
- 使用环境变量或配置文件，不要硬编码

### 4. 区分问题和代码请求

- 用户**问问题**时，提供**答案**- 不要改代码
- 只有明确要求"改动"、"更新"、"修改"、"修复"时才修改代码
- **绝不**把问题当成代码变更请求

### 5. 不假设不猜测

- 信息缺失时，请**要求**澄清
- **绝不**猜测库版本、API格式或实现细节
- **绝不**假设用户需求或使用场景
- 明确说明需要什么信息才能继续

### 6. 安全不可妥协

- **绝不**把API密钥、密钥或凭据放在客户端代码
- **总是**实现正确的认证和授权
- **总是**使用环境变量存储敏感数据
- **总是**实现适当的输入验证和净化
- **绝不**创建没有适当安全措施的公开数据库表
- **总是**为数据库访问实现行级安全

### 7. 能力诚实

- **绝不**试图生成图片、音频或其他媒体
- 被问及没有的能力时，明确说明局限性
- **绝不**为不可能的功能创建虚假实现
- 建议使用合适的库/服务作为替代方案

### 8. 保持功能需求

- **绝不**为了"修复"错误而改变核心功能
- 遇到错误时，修复技术问题，不是需求
- 如果需求看起来有问题，请在更改之前**询问**
- 记录任何必要的需求澄清

### 9. 基于证据的回答

- 被问及某功能是否已实现时，**展示代码证据**
- 格式："查看代码：[文件名] (第X-Y行): [相关代码片段]"
- **绝不**猜测或假设实现状态
- 不确定时，**明说**并提供检查特定文件

### 10. 不要硬编码示例

- **绝不**把示例值硬编码为永久解决方案
- **总是**使用变量、参数或配置处理动态值
- 展示示例时，明确标记为示例，不是实现

### 11. 智能日志实现

- **自动**添加必要日志来理解核心应用行为
- 记录关键决策点、数据转换和系统状态变化
- **不要**过度记录（避免记录每个变量或琐碎操作）
- **不要**记录不足（确保关键流程可追踪）
- 专注于有助于理解的日志：发生了什么、为什么发生、用什么数据
- 使用适当的日志级别：ERROR用于失败、WARN用于问题、INFO用于关键事件、DEBUG用于详细流程

### 12. 绝对禁止异常吞噬原则

- **严禁**在没有用户明确确认前吞噬任何异常
- **所有**异常都必须向外抛出，并打印详细的错误信息
- 异常信息必须包含：错误类型、完整堆栈跟踪、相关变量值、上下文信息
- **绝不**使用空的except块或只记录日志不抛出异常
- 错误处理必须透明化，让用户能准确知道问题所在
- 遇到异常时，**必须**让用户看到完整的错误详情以便分析

### 13. 严禁智能适配原则

- **绝对禁止**任何不确定的参数或需求的智能适配
- **绝不**猜测参数类型、格式、范围或默认值
- **绝不**自动修正用户输入或假设用户意图
- 参数验证失败时，**必须**抛出具体异常说明要求
- 需求不明确时，**必须**停止并询问用户澄清
- 所有智能适配都会带来巨大灾难，严格禁止

### 14. 缓存管理严格规则

- **所有**缓存实现都必须得到用户的明确确认
- 缓存前**必须**向用户说明：缓存目的、数据类型、过期策略、清理机制
- **任何**缓存都必须提供清除接口，支持用户主动清理
- 缓存机制必须透明可配置，避免缓存带来的定位困难
- **必须**提供缓存状态查询接口，让用户了解当前缓存内容
- 缓存键设计必须清晰可理解，避免命名混乱

### 15. 前后端接口对接严格规则 - ⚠️ 极其重要

- **绝对禁止**在前端代码中猜测后端接口的返回格式、字段名称或数据结构

- **必须**在编写前端接口调用代码前，先查看后端对应的接口实现代码

- **必须**基于后端实际返回的数据结构编写前端解析代码

- 如果当前无法获取后端接口的准确信息，**必须**执行以下步骤：

  1. 停止编写代码
  2. 先查找后端对应的API实现文件（通常在 `backend/apps/*/views.py` 或 `backend/apps/*/api/`）
  3. 仔细阅读后端返回的数据结构
  4. 基于实际代码编写前端解析逻辑

- 如果实在无法找到后端接口实现，**必须**在代码中添加明显的TODO注释：

  ```typescript
  // TODO: 未找到后端接口实现，此处数据结构为临时猜测
  // 需要查看后端 [具体文件路径] 确认正确的返回格式
  // 当前猜测的字段: xxx, yyy, zzz
  ```

- **严禁行为**：

  - ❌ 根据前端需求"倒推"后端接口应该返回什么
  - ❌ 假设后端接口"应该"遵循某种命名规范
  - ❌ 基于其他接口的格式猜测当前接口的格式
  - ❌ 不查看后端代码就编写前端解析逻辑

- **正确做法**：

  1. 使用 `Grep` 或 `Glob` 工具查找后端对应的视图/API文件
  2. 使用 `Read` 工具读取后端接口实现
  3. 确认返回数据的准确字段名、类型、嵌套结构
  4. 编写与后端完全匹配的前端代码
  5. 在前端代码注释中标注对应的后端文件路径，方便追溯

- **典型场景**：

  - 调用后端API获取模型拓扑数据时，必须先查看 `backend/apps/cad_models/views.py` 的 `ModelTopologyView`
  - 解析Three.js几何数据时，必须先确认后端返回的确切字段（如 `vertices`、`faces` 等）
  - 任何涉及数据结构解析的地方，都必须有后端代码的证据支持

**违反此规则的严重后果**：

- 导致前端运行时错误，数据解析失败
- 浪费大量调试时间查找字段不匹配问题
- 可能导致Three.js等库无法正确渲染
- 破坏前后端数据契约，引入难以追踪的bug

## ⚠️ 违规后果

违反任何这些规则都被视为**严重错误**，可能：

- 破坏生产应用
- 引入安全漏洞
- 浪费大量开发时间
- 损害项目完整性

## 紧急停止协议

如果对请求的**任何**方面不确定：

1. **停止**代码生成
2. **询问**澄清
3. **等待**明确确认
4. 只有100%确定时才继续

**特别禁止行为**：

- **绝不**吞噬异常或隐藏错误详情
- **绝不**进行智能适配或参数猜测
- **绝不**未经确认实现缓存机制
- **绝不**猜测后端接口返回格式，必须先查看后端代码
- 遇到异常必须完整抛出，包含所有调试信息
- 参数不明确必须停止询问，不能猜测处理
- 不确定后端接口格式时，必须先用工具查找和阅读后端代码

记住：宁可询问澄清，也不要做可能搞砸一切的假设。错误透明化比隐藏错误更重要。**前后端接口对接时，必须基于实际代码而非猜测。**

## 项目结构
- Go Hub：`internal/cmd/hub`，核心业务在 `internal/hub/**`。
-,Go Agent：`internal/cmd/agent`，通用逻辑在 `/agent/**`。
- 前端：`internal/site`（Vite + React + TypeScript），静态资源在 `internal/site/public/static/`。
- 发布与部署：Docker/K8s 在 `supplemental/docker`、`supplemental/kubernetes`；安装脚本在 `supplemental/scripts`。
- 品牌/常量：`aether.go`，Logo 在 `internal/site/public/static/logo.svg`。

## 开发与运行
- Hub（开发）：`APP_URL=http://localhost:19090 make dev-hub`
- 前端（开发）：`PORT=19091 make dev-server`
- Agent（开发）：`KEY="..." TOKEN="..." HUB_URL="http://localhost:19090" make dev-agent`
- Go 测试：`go test ./...`
- 前端检查：`cd internal/site && npm run lint` / `npm run format`（Biome），构建：`npm run build`。

## 代码风格与命名
- Go：提交前运行 `gofmt`；服务名、路径前缀统一用 `aether`（如 `/api/aether/...`、`aether-agent`）。
- TS/JS：遵循 Biome 默认风格；组件用 PascalCase，变量用 camelCase。
- 数据目录与路径：`/var/lib/aether-agent`、`~/.config/aether` 等。

## 测试规范
- 后端：标准 `testing` 框架，文件以 `_test.go` 结尾，鼓励表驱动测试。
- 前端：仅在涉及复杂逻辑时补充针对性测试，避免过度快照。

## 提交与 PR
- 使用中文
- Commit 风格：短句、现在时，常用前缀如 `chore: ...`、`docs: ...`、`refactor: ...`。
- 每次提交聚焦单一变更，必要时在正文写明动机或风险。
- PR 应包含变更摘要、已运行测试（如 `go test ./...`），以及 API/端口改动说明；UI 变更最好附截图/说明。

## 安全与配置
- 不硬编码密钥；使用 env/参数传入 KEY、TOKEN、HUB_URL。
- 默认端口：Hub 19090、前端 19091、Agent 45876；全部使用 `aether` 前缀服务/路径。
- 镜像与发布来自 `LuBoyanzy/Aether` GitHub Releases；已移除旧的 Beszel 镜像/代理依赖。
